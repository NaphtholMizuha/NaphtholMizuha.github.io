{"pages":[{"title":"","text":"{\"GZTime\":{\"url\":\"https://gztime.cc\",\"img\":\"https://gztime.cc/gzlogo.png\",\"text\":\"神。吾辈楷模。\"},\"Hanmur\":{\"url\":\"https://hanmur.cn\",\"img\":\"https://hanmur.cn/medias/avatar.png\",\"text\":\"卷王之一。密码学领域非专家研究者。\"},\"KangKangZi\":{\"url\":\"112.74.59.128\",\"img\":\"http://112.74.59.128/medias/avatar.jpg\",\"text\":\"卷王之二。提醒他赶紧把域名给备案上线了。\"}}","link":"/friends.json"},{"title":"","text":"kkbiss","link":"/about/index.html"},{"title":"亲友团","text":"希望大家都能活着。 &lt;&gt;","link":"/friends/index.html"}],"posts":[{"title":"Rust语言初级特性一览(一) 变量","text":"声明 Rust的变量声明非常简单，如下所示： 1let x = 114514; 请注意，在Rust语言中，形如上文x的变量是不可变的。也就是说，如果你尝试对x赋予另一个值，编译器会报错。除非在声明中加入mut关键字。 1234let x = 114514;let mut x_mut = 114514;x = 1919810; // Compile Error!x_mut = 1919810; // Passed 类型 类型是静态的 细心的读者可以发现，Rust声明变量似乎不需要类型。但Rust是一个静态语言，每个变量的类型都是确定且固定的。Rust拥有一个非常完善的类型匹配机制，可以在编译阶段自动推断每一个变量的确切类型。 例如上一节的这句代码： 1let x = 114514; 变量x的类型已经由赋予的值114514确定，而在Rust中形如114514的整数默认为i32类型，类似C语言中的int类型。下面几节将会介绍一些常见类型 标量类型 顾名思义，这种类型的变量只含有一个值。分为以下几种。 整型 用于表示整数，根据有无符号以及长度区别不同： 长度 有符号 无符号 8-bit i8 u8 16-bit i16 u16 32-bit i32 u32 64-bit i64 u64 128-bit i128 u128 由架构决定 isize usize 在32位机上isize的长度是32-bit，在64位机上则是64-bit，以此类推。 一般整形变量以十进制的形式给出，当然可以用0b 0o 0x 前缀分别表示二进制、八进制和十六进制数。","link":"/2022/02/21/Rust%E8%AF%AD%E8%A8%80%E5%88%9D%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%80%E8%A7%88-%E4%B8%80/"},{"title":"Hexo Icarus中友情链接卡片预览","text":"I'm in a box.","link":"/2022/02/21/Hexo-Icarus%E4%B8%AD%E5%8F%8B%E6%83%85%E9%93%BE%E6%8E%A5%E5%8D%A1%E7%89%87%E9%A2%84%E8%A7%88/"},{"title":"Cache","text":"直接映射 根据主存地址直接分配cache地址的方式。 对于已知块地址 \\(a\\) ，cache的块数 \\(n\\)，则我们可以得到cache中的地址： \\[ a_{\\text{cache}} = a\\mod n \\] graph LR; 主存 --- Cache --- reg(CPU寄存器) 特点 优点 实现简单，只需要利用主存地址和块地址进行比较确定是否命中。 缺点 映射关系不灵活，Cache会出现许多空闲。 AMAT（平均内存访问时间） \\[ \\text{AMAT} = \\text{命中时间} + \\text{失误率} \\times \\text{失误代价} \\] 级联Cache 一般来说，二级缓存比一级缓存大得多。","link":"/2022/01/05/cache/"},{"title":"双鸭山大学OS实验课前期准备指北","text":"本文参考双鸭山大学OS教学课题组的这篇文章归纳而成。 ## 准备Linux系统 对于Windows系统，推荐使用Virtual Box软件，官方链接点这里。 还需要准备Ubuntu系统镜像，官方链接点这里，推荐下载20.04.3LTS版本。 具体配置可以参考知乎的这篇文章。 进入系统之后进入下一步。 安装环境 在Ubuntnu中打开“终端”程序，这个程序相当于Windows中的cmd或者powershell，可以通过命令完成系统的全部工作，包括接下来的环境安装操作。 通用的软件安装指令是 1sudo apt install [软件名称] 安装编译测试环境 安装gcc编译器 1sudo apt install gcc 安装gdb调试器 1sudo apt install gdb 安装汇编编译器 1sudo apt install nasm 安装模拟器 安装qemu模拟器 1sudo apt install qemu 安装文本编辑器 更新索引 12sudo apt updatesudo apt install software-properties-common apt-transport-https wget 插入key 1wget -q https://packages.microsoft.com/keys/microsoft.asc -O- | sudo apt-key add - 添加VS Code的仓库 1sudo add-apt-repository &quot;deb [arch=amd64] https://packages.microsoft.com/repos/vscode stable main&quot; 安装VS Code 1sudo apt install code 然后就可以在桌面看到VS Code的图标，点进去就是熟悉的味道。 安装VS Code插件 推荐以下插件 C/C++ CMake CMake tools","link":"/2022/02/21/%E5%8F%8C%E9%B8%AD%E5%B1%B1%E5%A4%A7%E5%AD%A6OS%E5%AE%9E%E9%AA%8C%E8%AF%BE%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87%E6%8C%87%E5%8C%97/"},{"title":"$\\chi^2$ 分布","text":"定义 设 \\(n\\) 维随机独立变量 \\(\\vec{X}\\), \\(X_i \\sim N(0,1)\\) ,则称 \\[ \\def\\sumi{\\sum_{i = 1}^n} \\chi_n^2 = \\sumi X_i^2 \\] 服从自由度为 \\(n\\) 的 \\(\\chi^2\\) 分布,记为 \\(\\chi_n^2 \\sim \\chi^2(n)\\) 性质 概率密度 \\(\\chi^2 (n)\\) 的概率密度是 \\[ f(y) = \\begin{cases} \\displaystyle{\\frac{1}{2^{n/2} \\Gamma(n/2)} y^{n/2-1} \\mathrm e^{-y/2}}, \\quad y &gt; 0 \\\\\\\\ 0, \\quad \\text{else} \\end{cases} \\] 可加性 对于两个相互独立的随机变量 \\(\\chi_1^2 \\sim \\chi^2(n_1), \\chi_2^2 \\sim \\chi^2(n_2)\\) 有: \\[ \\chi_1 + \\chi_2 \\sim \\chi^2(n_1 + n_2) \\] 期望&amp;方差 \\[ \\chi^2 \\sim \\chi^2(n) \\implies \\mathrm E(\\chi^2) = n, \\quad \\mathrm D(\\chi^2) = 2n \\] 分位点 对于给定 \\(\\alpha \\in (0,1)\\),若满足 \\[ P\\{\\chi^2 &gt; \\chi_\\alpha^2 (n) \\} = \\int_{\\chi_\\alpha^2(n)}^\\infty f(y)\\mathrm d y = \\alpha \\] 则称 \\(\\chi_\\alpha^2(n)\\) 为 \\(\\chi^2\\) 分布的上\\(\\alpha\\)分位点 教材上有 \\(n &lt; 40\\) 条件下 \\(\\chi^2\\) 分布的上 \\(\\alpha\\) 分位点.对于 $n &gt; 40 $的情况,可以使用 R.A.Fisher 的公式 \\[ \\chi_\\alpha^2(n) \\approx \\frac{1}{2}(z_\\alpha + \\sqrt{2n-1})^2 \\] 其中 \\(z_\\alpha\\)是标准正态分布的上 \\(\\alpha\\) 分位点","link":"/2021/12/03/chi-2-%E5%88%86%E5%B8%83/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","link":"/2021/11/21/hello-world/"},{"title":"操作系统入门","text":"计算机四个部分 计算机硬件 CPU，内存，I/O设备... 操作系统 在硬件和用户之间控制和协调使用硬件 应用程序 文字编辑器 编译器 浏览器 数据库 ...... 用户 人 机器 其他计算机 OS是什么？ 资源分配器 控制所有的计算机资源 权衡冲突请求 控制程序 控制CPU时钟周期 避免错误和不当使用 没有广泛接受的定义 当你想要一个“操作系统”时，店员给的东西就是操作系统。 什么不是操作系统？ 系统程序不是（如IE、Windows Defender） 应用程序不是 系统操作 I/O设备和CPU可以同时执行 每个设备控制器都掌控一种特定设备类型 每个设备控制器都有本地缓存 CPU在主存和本地内存之间互相传输数据 中断 操作系统由中断 interrupt驱动 中断向量记录了特定中断及其处理进程。 中断处理的方法如下： 轮询技术：遍历所有可能的选项。 中断机制：可用选项就绪之后返回一个状态。 一般来说，中断技术会较好。大量数据处理时","link":"/2022/02/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/"},{"title":"积分与路径无关","text":"积分与路径无关 对于向量值函数 \\(\\boldsymbol{f}\\) ，其定义域 \\(D\\) 内任意曲线 \\(L\\)，都有 \\[ \\int_{L} \\begin{bmatrix}P(x,y)\\\\Q(x,y)\\end{bmatrix} \\cdot \\begin{bmatrix}\\mathrm dx\\\\\\mathrm dy\\end{bmatrix} \\equiv C \\] \\[ \\int_{L} \\boldsymbol{f(\\boldsymbol{x})} \\cdot \\mathrm d \\boldsymbol{s} \\equiv C \\] 它等价于 \\[ \\frac{\\partial P}{\\partial y} = \\frac{\\partial Q}{\\partial x} \\] \\[ \\begin{vmatrix} \\boldsymbol{i} &amp; \\boldsymbol{j} &amp; \\boldsymbol{k} \\\\ \\frac{\\partial}{\\partial x} &amp; \\frac{\\partial}{\\partial y} &amp; \\frac{\\partial}{\\partial z} \\\\ P &amp; Q &amp; R \\end{vmatrix} = 0 \\iff \\nabla \\times \\boldsymbol{f(\\boldsymbol{x})} = 0 \\] \\[ \\forall i,j \\in \\mathbb N(i\\ne j): \\begin{vmatrix} \\frac{\\partial}{\\partial x_{i}}&amp; \\frac{\\partial}{\\partial x_j}\\\\ \\frac{\\partial}{\\partial f_{i}}&amp; \\frac{\\partial}{\\partial f_j} \\end{vmatrix} = 0 \\] 求全微分的原函数 一个必要条件：积分与路径无关 给定全微分 \\(\\mathrm du = \\begin{bmatrix}P(x,y)\\\\Q(x,y)\\end{bmatrix} \\cdot \\begin{bmatrix}\\mathrm dx\\\\\\mathrm dy\\end{bmatrix}\\) 如果积分与路径无关，则其全微分的原函数为 \\[ u = \\int_{x_{0}}^{x} P(x,y_0)\\mathrm dx + \\int_{y_{0}}^{y} Q(x,y)\\mathrm dy \\] 其中 \\(x\\) 和 \\(y\\) 可以替换位置。","link":"/2022/01/05/%E7%A7%AF%E5%88%86%E4%B8%8E%E8%B7%AF%E5%BE%84%E6%97%A0%E5%85%B3/"},{"title":"流水线CPU中的问题处理","text":"数据冒险 执行时间 \\[ \\text{CPU time} = (N + 4 + s) \\times \\text{Cycle time} \\] 其中 \\(N\\) 是指令数，\\(s\\) 是阻塞周期数。 R型指令冒险：转发技术 Load-Use冒险：转发-阻塞技术 不能彻底解决，必须要延迟（阻塞 stall）1个周期。 不过有些地方有可能可以在 lw 指令后面马上转发到 sw 指令使用。 阻塞方法：PC不更新就可以了。 编译器优化技术 可以通过调整指令的顺序来避免Load阻塞。 例如 12a = b + cd = e - f 控制冒险（Control Hazards） jump只需要阻塞一个周期，且比例很小，所以一般不管。 但是beq bne 需要阻塞3个周期，且有一定规模，该管。 洗刷 阻塞时没有指令进入WB阶段，所以没有问题。 提前决定 如果在EX阶段中判断，就只需要阻塞2个周期。需要加装一个与门和 \\(2 \\times 1\\) 的MUX 如果增加硬件在ID阶段完成，就只需要阻塞1个周期。需要引入转发电路。 若判断的数据取决于前面指令的结果怎么办？ 可以在ALU应用转发技术。 分支预测 通过预测分支是否发生来判断。 总不发生 总是假设分支不发生来执行流水线。 如果实际上分支不发生，则就当无事发生，阻塞为1周期。 如果分支发生了，则立即洗刷流水线里面的全部指令，依靠新的PC重新开始处理，阻塞为3周期。 总发生 这种假设太烂了，损失效率，没人用。 动态预测 需要在IF阶段实现一个分支预测缓存（BHT），以PC地位地址为索引记录是否发生历史转移。why？ 如果命中（表内存在相同跳转地址）则直接在ID阶段取出目标地址。 如果没有命中，则插入新项目：指令地址、预测位和转移目标地址。 BHT只管地位地址相同的分支指令预测。 分支延迟 将前面不相关的指令转移到beq的后面来填充延迟时间，实在填不了就加一个nop。 对于j指令而言，第一周期取出j指令，第二周期取出下一个指令，第三周期再取出跳转后地址，一定会有一个指令是错误的。 总结 控制冒险有以下解决方案： - 硬件阻塞3个周期运行。 - 编译器插入3个nop指令。 - 分支预测 - 静态预测：总是预测不跳转。 - 动态预测：根据历史记录预测。 - 分支延迟：编译器调换指令位置满足延迟槽。 异常和中断 发生异常后的中断可能导致控制冒险。","link":"/2021/12/14/%E6%B5%81%E6%B0%B4%E7%BA%BFCPU%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/"},{"title":"积分变量替换","text":"积分变量替换可以大幅简化计算量，但是比较耗费脑子。 极坐标变换 普通极坐标变换 通过 \\[ \\begin{cases} x = r \\cos \\theta \\\\ y = r \\sin \\theta \\\\ \\end{cases} \\] 进行变换，此时， \\[ \\det J = \\begin{vmatrix} \\cos \\theta &amp; -r \\sin \\theta \\\\ \\sin \\theta &amp; r \\cos \\theta \\end{vmatrix} = r \\] 则有： \\[ \\def\\diff{\\mathrm d} \\iint_D f(x,y)\\diff x \\diff y = \\iint_\\Delta f(r\\cos \\theta, r \\sin \\theta)\\cdot r \\diff r \\diff \\theta \\]","link":"/2021/11/22/%E7%A7%AF%E5%88%86%E5%8F%98%E9%87%8F%E6%9B%BF%E6%8D%A2/"},{"title":"第二型曲面积分","text":"来源——流量计算 已知一个流量场 \\(\\vec{v}(x,y,z)\\) 求一个（单向）曲面上的流量和。 类似的问题的结果称为第二型曲面积分，写作 \\[ \\iint\\limits_{\\Sigma} \\boldsymbol{v}(x,y,z) \\cdot \\mathrm{d} \\vec{S} = \\iint\\limits_{\\Sigma} {v}_{x}(x,y,z) \\mathrm dy \\mathrm dz+ \\iint\\limits_{\\Sigma} {v}_{y}(x,y,z) \\mathrm dz \\mathrm dx+ \\iint\\limits_{\\Sigma} {v}_{z}(x,y,z) \\mathrm dx \\mathrm dy \\] 一些简单性质 当向量场分片光滑时且在积分曲面有定义时，第二型曲面积分存在。 区域可加性 转为第一型曲面积分 普通形式 如果曲面可以用 \\(z = z(x,y)\\) 表示，则 \\[ \\iint\\limits_{\\Sigma} {v}_{z}(x,y,z) \\mathrm dx \\mathrm dy = \\pm \\iint\\limits_{D} {v}_{z}(x,y,z(x,y)) \\mathrm dx \\mathrm dy \\] 其他两个分量也可以类似处理。 参数形式 如果曲面可以用 \\(\\begin{cases}x=x(u,v) \\\\ y = y(u,v) \\\\ z = z(u,v) \\end{cases}\\) 表示，则 \\[ \\iint\\limits_{\\Sigma} {v}_{z}(x,y,z) \\mathrm dx \\mathrm dy = \\pm \\iint\\limits_{D} {v}_{z}(x(u,v),y(u,v),z(u,v)) \\left|\\frac{\\partial(x,y)}{\\partial(u,v)}\\right|\\mathrm du \\mathrm dv \\] 其他两个分量类似。","link":"/2021/12/13/%E7%AC%AC%E4%BA%8C%E5%9E%8B%E6%9B%B2%E9%9D%A2%E7%A7%AF%E5%88%86/"},{"title":"Rust语言初级特性一览(零) 怎么玩Rust?","text":"Rust是什么 Rust是一种具有多种开发用途的现代编程语言。 如何体验？ 可以参考Rust官网的连接安装开发环境，或者仅仅通过这个在线环境来体验Rust的特性。 文章的目的？ 显然一个语言的所有特性不可能被简单地用一篇文章概括，笔者仅仅是提供一个概览，介绍Rust语言的独到之处。如果想要系统地学习不妨查阅Rust的官方教程。 Hello, world 123fn main() { println!(&quot;Hello, world!&quot;);}","link":"/2022/02/20/%E8%BF%81%E7%A7%BB%EF%BC%9FRust%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7%E4%B8%80%E8%A7%88/"}],"tags":[{"name":"Rust","slug":"Rust","link":"/tags/Rust/"},{"name":"教程","slug":"教程","link":"/tags/%E6%95%99%E7%A8%8B/"},{"name":"编程","slug":"编程","link":"/tags/%E7%BC%96%E7%A8%8B/"},{"name":"预览","slug":"预览","link":"/tags/%E9%A2%84%E8%A7%88/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Icarus","slug":"Icarus","link":"/tags/Icarus/"},{"name":"底层原理","slug":"底层原理","link":"/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"},{"name":"计算机组成原理","slug":"计算机组成原理","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"name":"操作系统","slug":"操作系统","link":"/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"数学","slug":"数学","link":"/tags/%E6%95%B0%E5%AD%A6/"},{"name":"概率论与数理统计","slug":"概率论与数理统计","link":"/tags/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/"},{"name":"微积分","slug":"微积分","link":"/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/"}],"categories":[{"name":"Rust概览","slug":"Rust概览","link":"/categories/Rust%E6%A6%82%E8%A7%88/"},{"name":"课程笔记","slug":"课程笔记","link":"/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"}]}