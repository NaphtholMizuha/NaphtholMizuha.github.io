{"pages":[{"title":"","text":"kkbiss","link":"/about/index.html"}],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","link":"/2021/11/21/hello-world/"},{"title":"$\\chi^2$ 分布","text":"定义 设 \\(n\\) 维随机独立变量 \\(\\vec{X}\\), \\(X_i \\sim N(0,1)\\) ,则称 \\[ \\def\\sumi{\\sum_{i = 1}^n} \\chi_n^2 = \\sumi X_i^2 \\] 服从自由度为 \\(n\\) 的 \\(\\chi^2\\) 分布,记为 \\(\\chi_n^2 \\sim \\chi^2(n)\\) 性质 概率密度 \\(\\chi^2 (n)\\) 的概率密度是 \\[ f(y) = \\begin{cases} \\displaystyle{\\frac{1}{2^{n/2} \\Gamma(n/2)} y^{n/2-1} \\mathrm e^{-y/2}}, \\quad y &gt; 0 \\\\\\\\ 0, \\quad \\text{else} \\end{cases} \\] 可加性 对于两个相互独立的随机变量 \\(\\chi_1^2 \\sim \\chi^2(n_1), \\chi_2^2 \\sim \\chi^2(n_2)\\) 有: \\[ \\chi_1 + \\chi_2 \\sim \\chi^2(n_1 + n_2) \\] 期望&amp;方差 \\[ \\chi^2 \\sim \\chi^2(n) \\implies \\mathrm E(\\chi^2) = n, \\quad \\mathrm D(\\chi^2) = 2n \\] 分位点 对于给定 \\(\\alpha \\in (0,1)\\),若满足 \\[ P\\{\\chi^2 &gt; \\chi_\\alpha^2 (n) \\} = \\int_{\\chi_\\alpha^2(n)}^\\infty f(y)\\mathrm d y = \\alpha \\] 则称 \\(\\chi_\\alpha^2(n)\\) 为 \\(\\chi^2\\) 分布的上\\(\\alpha\\)分位点 教材上有 \\(n &lt; 40\\) 条件下 \\(\\chi^2\\) 分布的上 \\(\\alpha\\) 分位点.对于 $n &gt; 40 $的情况,可以使用 R.A.Fisher 的公式 \\[ \\chi_\\alpha^2(n) \\approx \\frac{1}{2}(z_\\alpha + \\sqrt{2n-1})^2 \\] 其中 \\(z_\\alpha\\)是标准正态分布的上 \\(\\alpha\\) 分位点","link":"/2021/12/03/chi-2-%E5%88%86%E5%B8%83/"},{"title":"第二型曲面积分","text":"来源——流量计算 已知一个流量场 \\(\\vec{v}(x,y,z)\\) 求一个（单向）曲面上的流量和。 类似的问题的结果称为第二型曲面积分，写作 \\[ \\iint\\limits_{\\Sigma} \\boldsymbol{v}(x,y,z) \\cdot \\mathrm{d} \\vec{S} = \\iint\\limits_{\\Sigma} {v}_{x}(x,y,z) \\mathrm dy \\mathrm dz+ \\iint\\limits_{\\Sigma} {v}_{y}(x,y,z) \\mathrm dz \\mathrm dx+ \\iint\\limits_{\\Sigma} {v}_{z}(x,y,z) \\mathrm dx \\mathrm dy \\] 一些简单性质 当向量场分片光滑时且在积分曲面有定义时，第二型曲面积分存在。 区域可加性 转为第一型曲面积分 普通形式 如果曲面可以用 \\(z = z(x,y)\\) 表示，则 \\[ \\iint\\limits_{\\Sigma} {v}_{z}(x,y,z) \\mathrm dx \\mathrm dy = \\pm \\iint\\limits_{D} {v}_{z}(x,y,z(x,y)) \\mathrm dx \\mathrm dy \\] 其他两个分量也可以类似处理。 参数形式 如果曲面可以用 \\(\\begin{cases}x=x(u,v) \\\\ y = y(u,v) \\\\ z = z(u,v) \\end{cases}\\) 表示，则 \\[ \\iint\\limits_{\\Sigma} {v}_{z}(x,y,z) \\mathrm dx \\mathrm dy = \\pm \\iint\\limits_{D} {v}_{z}(x(u,v),y(u,v),z(u,v)) \\left|\\frac{\\partial(x,y)}{\\partial(u,v)}\\right|\\mathrm du \\mathrm dv \\] 其他两个分量类似。","link":"/2021/12/13/%E7%AC%AC%E4%BA%8C%E5%9E%8B%E6%9B%B2%E9%9D%A2%E7%A7%AF%E5%88%86/"},{"title":"积分变量替换","text":"积分变量替换可以大幅简化计算量，但是比较耗费脑子。 \\[ \\def\\diff{\\mathrm d} \\] 极坐标变换 普通极坐标变换 通过 \\[ \\begin{cases} x = r \\cos \\theta \\\\\\\\ y = r \\sin \\theta \\\\\\\\ \\end{cases} \\] 进行变换，此时， \\[ \\det J = \\begin{vmatrix} \\cos \\theta &amp; -r \\sin \\theta \\\\\\\\ \\sin \\theta &amp; r \\cos \\theta \\end{vmatrix} = r \\] 则有： \\[ \\iint_D f(x,y)\\diff x \\diff y = \\iint_\\Delta f(r\\cos \\theta, r \\sin \\theta)\\cdot r \\diff r \\diff \\theta \\]","link":"/2021/11/22/%E7%A7%AF%E5%88%86%E5%8F%98%E9%87%8F%E6%9B%BF%E6%8D%A2/"},{"title":"流水线CPU中的问题处理","text":"数据冒险 执行时间 \\[ \\text{CPU time} = (N + 4 + s) \\times \\text{Cycle time} \\] 其中 \\(N\\) 是指令数，\\(s\\) 是阻塞周期数。 R型指令冒险：转发技术 Load-Use冒险：转发-阻塞技术 不能彻底解决，必须要延迟（阻塞 stall）1个周期。 不过有些地方有可能可以在 lw 指令后面马上转发到 sw 指令使用。 阻塞方法：PC不更新就可以了。 编译器优化技术 可以通过调整指令的顺序来避免Load阻塞。 例如 12a = b + cd = e - f 控制冒险（Control Hazards） jump只需要阻塞一个周期，且比例很小，所以一般不管。 但是beq bne 需要阻塞3个周期，且有一定规模，该管。 洗刷 阻塞时没有指令进入WB阶段，所以没有问题。 提前决定 如果在EX阶段中判断，就只需要阻塞2个周期。需要加装一个与门和 \\(2 \\times 1\\) 的MUX 如果增加硬件在ID阶段完成，就只需要阻塞1个周期。需要引入转发电路。 若判断的数据取决于前面指令的结果怎么办？ 可以在ALU应用转发技术。 分支预测 通过预测分支是否发生来判断。 总不发生 总是假设分支不发生来执行流水线。 如果实际上分支不发生，则就当无事发生，阻塞为1周期。 如果分支发生了，则立即洗刷流水线里面的全部指令，依靠新的PC重新开始处理，阻塞为3周期。 总发生 这种假设太烂了，损失效率，没人用。 动态预测 需要在IF阶段实现一个分支预测缓存（BHT），以PC地位地址为索引记录是否发生历史转移。why？ 如果命中（表内存在相同跳转地址）则直接在ID阶段取出目标地址。 如果没有命中，则插入新项目：指令地址、预测位和转移目标地址。 BHT只管地位地址相同的分支指令预测。 分支延迟 将前面不相关的指令转移到beq的后面来填充延迟时间，实在填不了就加一个nop。 对于j指令而言，第一周期取出j指令，第二周期取出下一个指令，第三周期再取出跳转后地址，一定会有一个指令是错误的。 总结 控制冒险有以下解决方案： - 硬件阻塞3个周期运行。 - 编译器插入3个nop指令。 - 分支预测 - 静态预测：总是预测不跳转。 - 动态预测：根据历史记录预测。 - 分支延迟：编译器调换指令位置满足延迟槽。 异常和中断 发生异常后的中断可能导致控制冒险。","link":"/2021/12/14/%E6%B5%81%E6%B0%B4%E7%BA%BFCPU%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/"},{"title":"积分与路径无关","text":"积分与路径无关 对于向量值函数 \\(\\boldsymbol{f}\\) ，其定义域 \\(D\\) 内任意曲线 \\(L\\)，都有 \\[ \\int_{L} \\begin{bmatrix}P(x,y)\\\\Q(x,y)\\end{bmatrix} \\cdot \\begin{bmatrix}\\mathrm dx\\\\\\mathrm dy\\end{bmatrix} \\equiv C \\] \\[ \\int_{L} \\boldsymbol{f(\\boldsymbol{x})} \\cdot \\mathrm d \\boldsymbol{s} \\equiv C \\] 它等价于 \\[ \\frac{\\partial P}{\\partial y} = \\frac{\\partial Q}{\\partial x} \\] \\[ \\begin{vmatrix} \\boldsymbol{i} &amp; \\boldsymbol{j} &amp; \\boldsymbol{k} \\\\ \\frac{\\partial}{\\partial x} &amp; \\frac{\\partial}{\\partial y} &amp; \\frac{\\partial}{\\partial z} \\\\ P &amp; Q &amp; R \\end{vmatrix} = 0 \\iff \\nabla \\times \\boldsymbol{f(\\boldsymbol{x})} = 0 \\] \\[ \\forall i,j \\in \\mathbb N(i\\ne j): \\begin{vmatrix} \\frac{\\partial}{\\partial x_{i}}&amp; \\frac{\\partial}{\\partial x_j}\\\\ \\frac{\\partial}{\\partial f_{i}}&amp; \\frac{\\partial}{\\partial f_j} \\end{vmatrix} = 0 \\] 求全微分的原函数 一个必要条件：积分与路径无关 给定全微分 \\(\\mathrm du = \\begin{bmatrix}P(x,y)\\\\Q(x,y)\\end{bmatrix} \\cdot \\begin{bmatrix}\\mathrm dx\\\\\\mathrm dy\\end{bmatrix}\\) 如果积分与路径无关，则其全微分的原函数为 \\[ u = \\int_{x_{0}}^{x} P(x,y_0)\\mathrm dx + \\int_{y_{0}}^{y} Q(x,y)\\mathrm dy \\] 其中 \\(x\\) 和 \\(y\\) 可以替换位置。","link":"/2022/01/05/%E7%A7%AF%E5%88%86%E4%B8%8E%E8%B7%AF%E5%BE%84%E6%97%A0%E5%85%B3/"},{"title":"cache","text":"直接映射 根据主存地址直接分配cache地址的方式。 对于已知块地址 \\(a\\) ，cache的块数 \\(n\\)，则我们可以得到cache中的地址： \\[ a_{\\text{cache}} = a\\mod n \\] 12graph LR;主存 --- Cache --- reg(CPU寄存器) 特点 优点 实现简单，只需要利用主存地址和块地址进行比较确定是否命中。 缺点 映射关系不灵活，Cache会出现许多空闲。 AMAT（平均内存访问时间） \\[ \\text{AMAT} = \\text{命中时间} + \\text{失误率} \\times \\text{失误代价} \\] 级联Cache 一般来说，二级缓存比一级缓存大得多。","link":"/2022/01/05/cache/"}],"tags":[{"name":"数学分析, 曲面积分","slug":"数学分析-曲面积分","link":"/tags/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90-%E6%9B%B2%E9%9D%A2%E7%A7%AF%E5%88%86/"},{"name":"数学分析, 变量替换","slug":"数学分析-变量替换","link":"/tags/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90-%E5%8F%98%E9%87%8F%E6%9B%BF%E6%8D%A2/"},{"name":"计组","slug":"计组","link":"/tags/%E8%AE%A1%E7%BB%84/"}],"categories":[]}